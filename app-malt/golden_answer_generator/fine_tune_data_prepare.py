import json

# Sample dat
# For each prompt, please spcify the returned type you want.
prompts = [
    # 3 easy ones
    "List all ports contained in packet switch ju1.a1.m1.s2c1. Return a list.",
    "Add a new packet_switch 'ju1.a1.m1.s4c7' on jupiter 1, aggregation block 1, domain 1, with 5 ports, each port has physical_capacity_bps as 1000. Add node type and edges too. Return the new graph.",
    "Update the physical_capacity_bps from 1000 Mbps to 4000 Mbps on node ju1.a1.m1.s2c2.p14. Convert Mbps to bps before the update. Return the new graph.",
    # 2nd turn
    "Identify all CONTROL_POINT nodes that are also PACKET_SWITCH type within the AGG_BLOCK type node ju1.a4.m4. Return a list.",
    "Display all CONTROL_DOMAIN that contains at least 3 CONTROL_POINT. Return a list.",
    "Update all PACKET_SWITCH with node attr packet_switch_attr{switch_loc {stage: 3}} to packet_switch_attr{switch_loc {stage: 5}}. Return the graph.",
    "Find the number of CHASSIS nodes contained in each RACK node? Return a table with headers 'RACK', 'CHASSIS Count'.",

    # 3 medium one
    "What is the bandwidth on packet switch ju1.a2.m1.s2c2? Output bandwidth unit should be in Mbps. Return only the number.",
    "What is the bandwidth on each AGG_BLOCK? Output bandwidth unit should be in Mbps. Return a table with header 'AGG_BLOCK', 'Bandwidth' on the first row.",
    "Find the first and the second largest Chassis by capacity on 'ju1.a1.m1'. Output bandwidth unit should be in Mbps. Return a table with header 'Chassis', 'Bandwidth' on the first row.",
    # 2nd turn
    "Show the average physical_capacity_bps for all PORT in all PACKET_SWITCH. Return a number in string.",
    "For each AGG_BLOCK, list the number of PACKET_SWITCH and PORT it contains. Return a table with headers 'AGG_BLOCK', 'Switch Count', 'Port Count'.",
    "Identify all PACKET_SWITCH nodes contains in AGG_BLOCK node ju1.a1.m1 and calculate their average physical_capacity_bps (on PORT) in bps. Return a table with headers 'Packet Switch', Average Capacity (bps)', sort by highest average capacity.",
    "Find all PACKET_SWITCH nodes that have capacity more than the average. Return a list of nodes.",

    # 3 hard ones
    "Provide a graph that contains all SUPERBLOCK and AGG_BLOCK. Create the new graph.",
    "Remove packet switch 'ju1.a1.m1.s2c4' out from Chassis c4, how to balance the capacity between Chassis? Return the balanced graph.",
    "Remove five PORT nodes (start from p1) from each PACKET_SWITCH node ju1.a1.m1.s2c1, ju1.a1.m1.s2c2, ju1.a1.m1.s2c3, ju1.a1.m1.s2c4, ju1.a1.m1.s2c5. Make sure after the removal the capacity between switches is still balanced. Return the list of ports that will be moved.",
    # 2nd turn
    "Identify all paths from the CONTROL_DOMAIN type node ju1.a1.dom to PORT node ju1.a1.m1.s2c1.p1, and rank them based on the lowest number of hops.",
    "Analyze the redundancy level of each SUPERBLOCK node, by calculating the number of alternative paths between pairs of CHASSIS nodes contains in SUPERBLOCK.",
    "Optimize the current network topology by identifying PACKET_SWITCH nodes that can be removed without affecting the connectivity between CONTROL_DOMAIN nodes. Return a list.",

]

answers=[
    # 3 easy ones
    "\ndef ground_truth_process_graph(graph_data):\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1.s2c1' and 'EK_PACKET_SWITCH' in graph_data.nodes[node]['type']:\n            target_node = node\n            break\n\n    if target_node is None:\n        return {'type': 'text', 'data': 'Packet switch not found'}\n\n    ports = []\n    for edge in graph_data.out_edges(target_node, data=True):\n        if edge[2]['type'] == 'RK_CONTAINS':\n            destination_node = edge[1]\n            if 'EK_PORT' in graph_data.nodes[destination_node]['type']:\n                ports.append(graph_data.nodes[destination_node]['name'])\n\n    return {'type': 'list', 'data': ports}",
    "\ndef ground_truth_process_graph(graph_data):\n    # Create a copy of the graph\n    graph_copy = graph_data.copy()\n\n    # Create a new node for the packet_switch 'ju1.a1.m1.s4c7'\n    packet_switch_node = 'ju1.a1.m1.s4c7'\n    graph_copy.add_node(packet_switch_node, type=['EK_PACKET_SWITCH'])\n\n    # Add ports to the packet_switch\n    for i in range(1, 6):\n        port_node = packet_switch_node + '.p' + str(i)\n        graph_copy.add_node(port_node, type=['EK_PORT'], physical_capacity_bps=1000)\n        graph_copy.add_edge(packet_switch_node, port_node, type='RK_CONTAINS')\n\n    # Add the packet_switch to the corresponding jupiter, aggregation block, and domain\n    jupiter_node = 'ju1'\n    agg_block_node = 'ju1.a1'\n    domain_node = 'ju1.a1.m1'\n\n    if not graph_copy.has_node(jupiter_node):\n        graph_copy.add_node(jupiter_node, type=['EK_JUPITER'])\n    if not graph_copy.has_node(agg_block_node):\n        graph_copy.add_node(agg_block_node, type=['EK_AGG_BLOCK'])\n    if not graph_copy.has_node(domain_node):\n        graph_copy.add_node(domain_node, type=['EK_DOMAIN'])\n\n    graph_copy.add_edge(jupiter_node, agg_block_node, type='RK_CONTAINS')\n    graph_copy.add_edge(agg_block_node, domain_node, type='RK_CONTAINS')\n    graph_copy.add_edge(domain_node, packet_switch_node, type='RK_CONTAINS')\n\n    return_object = {'type': 'graph', 'data': graph_copy}\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Find the node with the specified name\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1.s2c2.p14':\n            target_node = node\n            break\n\n    # Update the physical_capacity_bps attribute\n    if target_node is not None:\n        graph_data.nodes[target_node]['physical_capacity_bps'] = 4000 * 1000000\n\n    return_object = {\n        'type': 'graph',\n        'data': graph_data\n    }\n\n    return return_object",
    # 2nd turn
    "\ndef ground_truth_process_graph(graph_data):\n    control_point_packet_switch_nodes = []\n    \n    for node in graph_data.nodes(data=True):\n        if 'EK_CONTROL_POINT' in node[1]['type'] and 'EK_PACKET_SWITCH' in node[1]['type']:\n            for edge in graph_data.in_edges(node[0], data=True):\n                if edge[2]['type'] == 'RK_CONTAINS' and graph_data.nodes[edge[0]]['type'] == ['EK_AGG_BLOCK'] and graph_data.nodes[edge[0]]['name'] == 'ju1.a4.m4':\n                    control_point_packet_switch_nodes.append(node[0])\n                    break\n    \n    return_object = {\n        'type': 'list',\n        'data': control_point_packet_switch_nodes\n    }\n    \n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    control_domains = []\n    for node in graph_data.nodes(data=True):\n        if 'EK_CONTROL_DOMAIN' in node[1]['type']:\n            control_points = [edge[1] for edge in graph_data.out_edges(node[0], data=True) if edge[2]['type'] == 'RK_CONTAINS' and 'EK_CONTROL_POINT' in graph_data.nodes[edge[1]]['type']]\n            if len(control_points) >= 3:\n                control_domains.append(node[0])\n    return_object = {'type': 'list', 'data': control_domains}\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    for node, attrs in graph_data.nodes(data=True):\n        if 'EK_PACKET_SWITCH' in attrs['type']:\n            if attrs.get('packet_switch_attr', {}).get('switch_loc', {}).get('stage') == 3:\n                attrs['packet_switch_attr']['switch_loc']['stage'] = 5\n    return_object = {\n        'type': 'graph',\n        'data': graph_data\n    }\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    table_data = [['RACK', 'CHASSIS Count']]\n    for node in graph_data.nodes(data=True):\n        if 'EK_RACK' in node[1]['type']:\n            rack_node = node[0]\n            chassis_count = 0\n            for edge in graph_data.out_edges(rack_node, data=True):\n                if edge[2]['type'] == 'RK_CONTAINS':\n                    if 'EK_CHASSIS' in graph_data.nodes[edge[1]]['type']:\n                        chassis_count += 1\n            table_data.append([rack_node, chassis_count])\n    return_object = {'type': 'table', 'data': table_data}\n    return return_object",

    # 3 medium ones
    "\ndef ground_truth_process_graph(graph_data):\n    \n    # Find the packet switch node\n    packet_switch_node = None\n    for node in graph_data.nodes(data=True):\n        if 'EK_PACKET_SWITCH' in node[1]['type'] and node[0] == 'ju1.a2.m1.s2c2':\n            packet_switch_node = node[0]\n            break\n\n    if packet_switch_node is None:\n        return {'type': 'text', 'data': 'Packet switch not found'}\n\n    # Find all port nodes contained by the packet switch\n    port_nodes = []\n    for edge in graph_data.edges(data=True):\n        if edge[2]['type'] == 'RK_CONTAINS' and edge[0] == packet_switch_node:\n            port_nodes.append(edge[1])\n\n    # Sum the physical_capacity_bps attribute on the port nodes\n    total_bandwidth_bps = 0\n    for port_node in port_nodes:\n        total_bandwidth_bps += graph_data.nodes[port_node]['physical_capacity_bps']\n\n    # Convert to Mbps\n    total_bandwidth_mbps = total_bandwidth_bps / 1e6\n\n    return {'type': 'text', 'data': str(total_bandwidth_mbps)}",
    "\ndef ground_truth_process_graph(graph_data):\n    \n    agg_blocks = [node for node in graph_data.nodes if 'EK_AGG_BLOCK' in graph_data.nodes[node]['type']]\n    bandwidths = []\n\n    for agg_block in agg_blocks:\n        packet_switches = [node for node in graph_data.successors(agg_block) if 'EK_PACKET_SWITCH' in graph_data.nodes[node]['type']]\n        total_bandwidth = 0\n\n        for packet_switch in packet_switches:\n            ports = [node for node in graph_data.successors(packet_switch) if 'EK_PORT' in graph_data.nodes[node]['type']]\n\n            for port in ports:\n                total_bandwidth += graph_data.nodes[port]['physical_capacity_bps'] / 1e6  # Convert to Mbps\n\n        bandwidths.append([agg_block, total_bandwidth])\n\n    return_object = {\n        'type': 'table',\n        'data': [['AGG_BLOCK', 'Bandwidth']] + bandwidths\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    \n    # Helper function to convert bps to Mbps\n    def bps_to_mbps(bps):\n        return bps / (10**6)\n\n    # Find the 'ju1.a1.m1' node\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1':\n            target_node = node\n            break\n\n    # Find all Chassis nodes\n    chassis_nodes = [n for n in graph_data.nodes if 'EK_CHASSIS' in graph_data.nodes[n]['type']]\n\n    # Calculate the total bandwidth for each Chassis\n    chassis_bandwidth = {}\n    for chassis in chassis_nodes:\n        bandwidth = 0\n        packet_switch_nodes = [n for n in graph_data.neighbors(chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n        for packet_switch in packet_switch_nodes:\n            port_nodes = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n            for port in port_nodes:\n                bandwidth += graph_data.nodes[port]['physical_capacity_bps']\n        chassis_bandwidth[chassis] = bps_to_mbps(bandwidth)\n\n    # Sort Chassis by bandwidth\n    sorted_chassis = sorted(chassis_bandwidth.items(), key=lambda x: x[1], reverse=True)\n\n    # Get the first and second largest Chassis\n    top_chassis = sorted_chassis[:2]\n\n    # Create the table\n    table = [['Chassis', 'Bandwidth']]\n    for chassis, bandwidth in top_chassis:\n        table.append([chassis, bandwidth])\n\n    return_object = {\n        'type': 'table',\n        'data': table\n    }\n\n    return return_object",
    # 2nd turn
    "\ndef ground_truth_process_graph(graph_data):\n    total_capacity = 0\n    port_count = 0\n\n    for node in graph_data.nodes(data=True):\n        if 'EK_PACKET_SWITCH' in node[1]['type']:\n            for neighbor in graph_data.neighbors(node[0]):\n                neighbor_data = graph_data.nodes[neighbor]\n                if 'EK_PORT' in neighbor_data['type']:\n                    total_capacity += neighbor_data['physical_capacity_bps']\n                    port_count += 1\n\n    average_capacity = total_capacity / port_count if port_count > 0 else 0\n\n    return_object = {\n        'type': 'text',\n        'data': str(average_capacity)\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    agg_blocks = [n for n, d in graph_data.nodes(data=True) if 'EK_AGG_BLOCK' in d['type']]\n    result = []\n    for agg_block in agg_blocks:\n        switch_count = 0\n        port_count = 0\n        for node in nx.descendants(graph_data, agg_block):\n            if 'EK_PACKET_SWITCH' in graph_data.nodes[node]['type']:\n                switch_count += 1\n            elif 'EK_PORT' in graph_data.nodes[node]['type']:\n                port_count += 1\n        result.append([agg_block, switch_count, port_count])\n    \n    return_object = {\n        'type': 'table',\n        'data': [['AGG_BLOCK', 'Switch Count', 'Port Count']] + result\n    }\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    packet_switches = []\n    for node in graph_data.nodes(data=True):\n        if 'EK_AGG_BLOCK' in node[1]['type'] and node[1]['name'] == 'ju1.a1.m1':\n            for edge in graph_data.out_edges(node[0], data=True):\n                if edge[2]['type'] == 'RK_CONTAINS':\n                    dest_node = graph_data.nodes[edge[1]]\n                    if 'EK_PACKET_SWITCH' in dest_node['type']:\n                        packet_switches.append(edge[1])\n\n    avg_capacity = []\n    for ps in packet_switches:\n        capacities = []\n        for edge in graph_data.out_edges(ps, data=True):\n            if edge[2]['type'] == 'RK_CONTAINS':\n                dest_node = graph_data.nodes[edge[1]]\n                if 'EK_PORT' in dest_node['type']:\n                    capacities.append(dest_node['physical_capacity_bps'])\n        avg_capacity.append((ps, sum(capacities) / len(capacities)))\n\n    avg_capacity.sort(key=lambda x: x[1], reverse=True)\n    table_data = [['Packet Switch', 'Average Capacity (bps)']]\n    for item in avg_capacity:\n        table_data.append([item[0], item[1]])\n\n    return_object = {\n        'type': 'table',\n        'data': table_data\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Initialize the list to store packet switch nodes and their capacities\n    packet_switch_nodes = []\n    total_capacity = 0\n\n    # Iterate over all nodes in the graph\n    for node in graph_data.nodes(data=True):\n        # Check if the node is a packet switch\n        if 'EK_PACKET_SWITCH' in node[1]['type']:\n            # Calculate the total capacity of the packet switch\n            capacity = sum([graph_data.nodes[neighbor]['physical_capacity_bps'] for neighbor in graph_data.neighbors(node[0]) if 'EK_PORT' in graph_data.nodes[neighbor]['type']])\n            # Append the node and its capacity to the list\n            packet_switch_nodes.append((node[0], capacity))\n            total_capacity += capacity\n\n    # Calculate the average capacity\n    avg_capacity = total_capacity / len(packet_switch_nodes)\n\n    # Find all packet switch nodes that have capacity more than the average\n    result = [node for node, capacity in packet_switch_nodes if capacity > avg_capacity]\n\n    # Return the result\n    return_object = {'type': 'list', 'data': result}\n    return return_object",

    # 3 hard ones
    "\ndef ground_truth_process_graph(graph_data):\n    # Filter nodes and edges\n    filtered_nodes = [n for n, d in graph_data.nodes(data=True) if 'EK_SUPERBLOCK' in d['type'] or 'EK_AGG_BLOCK' in d['type']]\n    filtered_edges = [(u, v, d) for u, v, d in graph_data.edges(data=True) if d['type'] == 'RK_CONTAINS' and u in filtered_nodes or v in filtered_nodes]\n\n    # Create a new graph with the filtered nodes and edges\n    new_graph = nx.DiGraph()\n    new_graph.add_nodes_from(filtered_nodes)\n    new_graph.add_edges_from(filtered_edges)\n\n    # Return the graph object\n    return_object = {\n        'type': 'graph',\n        'data': new_graph\n    }\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Remove packet switch 'ju1.a1.m1.s2c4' from Chassis c4\n    packet_switch_to_remove = 'ju1.a1.m1.s2c4'\n    chassis_to_balance = 'c4'\n    if packet_switch_to_remove in graph_data.nodes():\n        graph_data.remove_node(packet_switch_to_remove)\n\n    # Find all Chassis nodes\n    chassis_nodes = [n for n, attr in graph_data.nodes(data=True) if 'EK_CHASSIS' in attr['type']]\n\n    # Calculate the total capacity for each Chassis\n    chassis_capacity = {}\n    for chassis in chassis_nodes:\n        packet_switches = [n for n in graph_data.neighbors(chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n        total_capacity = 0\n        for packet_switch in packet_switches:\n            ports = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n            for port in ports:\n                total_capacity += graph_data.nodes[port]['physical_capacity_bps']\n        chassis_capacity[chassis] = total_capacity\n\n    # Calculate the average capacity\n    average_capacity = sum(chassis_capacity.values()) / len(chassis_capacity)\n\n    # Balance the capacity between Chassis\n    for chassis in chassis_nodes:\n        if chassis_capacity[chassis] < average_capacity:\n            extra_capacity = average_capacity - chassis_capacity[chassis]\n            # Find a packet switch from another chassis with enough capacity\n            for other_chassis in chassis_nodes:\n                if other_chassis != chassis:\n                    other_packet_switches = [n for n in graph_data.neighbors(other_chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n                    for packet_switch in other_packet_switches:\n                        ports = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n                        packet_switch_capacity = sum(graph_data.nodes[port]['physical_capacity_bps'] for port in ports)\n                        if packet_switch_capacity >= extra_capacity:\n                            # Move the packet switch to the current chassis\n                            graph_data.remove_edge(other_chassis, packet_switch)\n                            graph_data.add_edge(chassis, packet_switch, type='RK_CONTAINS')\n                            break\n\n    return {'type': 'graph', 'data': graph_data}",
    "\ndef ground_truth_process_graph(graph_data):\n    packet_switches = ['ju1.a1.m1.s2c1', 'ju1.a1.m1.s2c2', 'ju1.a1.m1.s2c3', 'ju1.a1.m1.s2c4', 'ju1.a1.m1.s2c5']\n    removed_ports = []\n\n    for switch in packet_switches:\n        ports = [n for n in graph_data.neighbors(switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n        ports_capacity = {port: graph_data.nodes[port]['physical_capacity_bps'] for port in ports}\n        sorted_ports = sorted(ports_capacity.items(), key=lambda x: x[1], reverse=True)\n\n        for i in range(5):\n            removed_port = sorted_ports.pop(0)\n            removed_ports.append(removed_port[0])\n            graph_data.remove_node(removed_port[0])\n\n    return_object = {\n        'type': 'list',\n        'data': removed_ports\n    }\n\n    return return_object",
    # 2nd turn
    "\ndef ground_truth_process_graph(graph_data):\n    source_node = None\n    target_node = None\n\n    for node in graph_data.nodes(data=True):\n        if 'EK_CONTROL_DOMAIN' in node[1]['type'] and node[1]['name'] == 'ju1.a1.dom':\n            source_node = node[0]\n        if 'EK_PORT' in node[1]['type'] and node[1]['name'] == 'ju1.a1.m1.s2c1.p1':\n            target_node = node[0]\n\n    if source_node is None or target_node is None:\n        return {'type': 'text', 'data': 'Source or target node not found'}\n\n    all_paths = list(nx.all_simple_paths(graph_data, source_node, target_node))\n    ranked_paths = sorted(all_paths, key=len)\n\n    return {'type': 'list', 'data': ranked_paths}",
    "\ndef ground_truth_process_graph(graph_data):\n    def find_chassis_nodes(graph):\n        return [node for node, attrs in graph.nodes(data=True) if 'EK_CHASSIS' in attrs['type']]\n\n    def find_superblock_nodes(graph):\n        return [node for node, attrs in graph.nodes(data=True) if 'EK_SUPERBLOCK' in attrs['type']]\n\n    def find_chassis_in_superblock(graph, superblock):\n        return [node for node in graph.neighbors(superblock) if 'EK_CHASSIS' in graph.nodes[node]['type']]\n\n    def calculate_redundancy(graph, chassis_pairs):\n        redundancy = {}\n        for pair in chassis_pairs:\n            paths = nx.all_simple_paths(graph, source=pair[0], target=pair[1])\n            redundancy[pair] = len(list(paths)) - 1\n        return redundancy\n\n    chassis_nodes = find_chassis_nodes(graph_data)\n    superblock_nodes = find_superblock_nodes(graph_data)\n\n    redundancy_data = []\n    for superblock in superblock_nodes:\n        chassis_in_superblock = find_chassis_in_superblock(graph_data, superblock)\n        chassis_pairs = [(chassis1, chassis2) for idx1, chassis1 in enumerate(chassis_in_superblock) for chassis2 in chassis_in_superblock[idx1 + 1:]]\n        redundancy = calculate_redundancy(graph_data, chassis_pairs)\n        redundancy_data.append([superblock, redundancy])\n\n    return_object = {\n        'type': 'table',\n        'data': redundancy_data\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    \n    # Get all CONTROL_DOMAIN nodes\n    control_nodes = [node for node, attr in graph_data.nodes(data=True) if 'EK_CONTROL_DOMAIN' in attr['type']]\n\n    # Get all PACKET_SWITCH nodes\n    packet_switch_nodes = [node for node, attr in graph_data.nodes(data=True) if 'EK_PACKET_SWITCH' in attr['type']]\n\n    removable_nodes = []\n\n    for packet_node in packet_switch_nodes:\n        # Create a copy of the graph\n        graph_copy = graph_data.copy()\n\n        # Remove the packet node\n        graph_copy.remove_node(packet_node)\n\n        # Check if all control nodes are still connected\n        if nx.is_strongly_connected(graph_copy.subgraph(control_nodes)):\n            removable_nodes.append(packet_node)\n\n    return_object = {'type': 'list', 'data': removable_nodes}\n\n    return return_object",

]


# File to save the jsonl
output_file = 'malt-finetune.jsonl'

# Prepare data in the required format
data = []
for prompt, answer in zip(prompts, answers):
    entry = {
        "messages": [
            {"role": "system", "content": "You are a system to help network management"},
            {"role": "user", "content": prompt},
            {"role": "assistant", "content": answer},
            {"role": "system", "content": "You are a system to help network management"},
            {"role": "user", "content": prompt},
            {"role": "assistant", "content": answer}
        ]
    }
    data.append(entry)

# Write data to jsonl file
with open(output_file, 'w') as f:
    for entry in data:
        f.write(json.dumps(entry) + '\n')

print(f"Data successfully written to {output_file}")
