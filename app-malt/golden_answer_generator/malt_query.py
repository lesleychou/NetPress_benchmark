import pandas as pd
import json

df = pd.DataFrame()
prompt_df = pd.DataFrame()

# For each prompt, please specify the returned type you want.
prompts = [
    # 3 easy ones
    "List all ports contained in packet switch ju1.a1.m1.s2c1. Return a list.",
    "Add a new packet_switch 'ju1.a1.m1.s4c7' on jupiter 1, aggregation block 1, domain 1, with 5 ports, each port has physical_capacity_bps as 1000. Add node type and edges too. Return the new graph.",
    "Update the physical_capacity_bps from 1000 Mbps to 4000 Mbps on node ju1.a1.m1.s2c2.p14. Convert Mbps to bps before the update. Return the new graph.",
    # 2nd turn
    "Identify all CONTROL_POINT nodes that are also PACKET_SWITCH type within the AGG_BLOCK type node ju1.a4.m4. Return a list.",
    "Display all CONTROL_DOMAIN that contains at least 3 CONTROL_POINT. Return a list.",
    "Update all PACKET_SWITCH with node attr packet_switch_attr{switch_loc {stage: 3}} to packet_switch_attr{switch_loc {stage: 5}}. Return the graph.",
    "Find the number of CHASSIS nodes contained in each RACK node? Return a table with headers 'RACK', 'CHASSIS Count'.",

    # 3 medium one
    "What is the bandwidth on packet switch ju1.a2.m1.s2c2? Output bandwidth unit should be in Mbps. Return only the number.",
    "What is the bandwidth on each AGG_BLOCK? Output bandwidth unit should be in Mbps. Return a table with header 'AGG_BLOCK', 'Bandwidth' on the first row.",
    "Find the first and the second largest Chassis by capacity on 'ju1.a1.m1'. Output bandwidth unit should be in Mbps. Return a table with header 'Chassis', 'Bandwidth' on the first row.",
    # 2nd turn
    "Show the average physical_capacity_bps for all PORT in all PACKET_SWITCH. Return a number in string.",
    "For each AGG_BLOCK, list the number of PACKET_SWITCH and PORT it contains. Return a table with headers 'AGG_BLOCK', 'Switch Count', 'Port Count'.",
    "Identify all PACKET_SWITCH nodes contains in AGG_BLOCK node ju1.a1.m1 and calculate their average physical_capacity_bps (on PORT) in bps. Return a table with headers 'Packet Switch', Average Capacity (bps)', sort by highest average capacity.",
    "Find all PACKET_SWITCH nodes that have capacity more than the average. Return a list of nodes.",

    # 3 hard ones
    "Provide a graph that contains all SUPERBLOCK and AGG_BLOCK. Create the new graph.",
    "Remove packet switch 'ju1.a1.m1.s2c4' out from Chassis c4, how to balance the capacity between Chassis? Return the balanced graph.",
    "Remove five PORT nodes (start from p1) from each PACKET_SWITCH node ju1.a1.m1.s2c1, ju1.a1.m1.s2c2, ju1.a1.m1.s2c3, ju1.a1.m1.s2c4, ju1.a1.m1.s2c5. Make sure after the removal the capacity between switches is still balanced. Return the list of ports that will be moved.",
    # 2nd turn
    "Identify all paths from the CONTROL_DOMAIN type node ju1.a1.dom to PORT node ju1.a1.m1.s2c1.p1, and rank them based on the lowest number of hops.",
    "Analyze the redundancy level of each SUPERBLOCK node, by calculating the number of alternative paths between pairs of CHASSIS nodes contains in SUPERBLOCK.",
    "Optimize the current network topology by identifying PACKET_SWITCH nodes that can be removed without affecting the connectivity between CONTROL_DOMAIN nodes. Return a list.",
    "Determine the optimal placement of a new PACKET_SWITCH node ju1.a1.m1.s2c9 with 5 PORT nodes in the format ju1.a1.m1.s2c9.p{i} (each has physical_capacity_bps 1000000000). Consider the current physical_capacity_bps distribution. The goal is to balance average capacity between AGG_BLOCK. Return the networkx graph.",


    # From srikanth
    "What is the total capacity of all the ports of the packet switch ju1.a1.m1.s2c1? Return only the number",
    "How many packet switches have more capacity than ju1.a2.m3.s2c3? Can you give me an example of such a switch? Return the text",
    "How many packet switches are there in a typical chassis? Can you find me an example of a chassis with more or fewer switches than normal?",
    # "Can you explain to me what a PORT is? What kinds of children does it have? What kinds of parents does it have?",
    "How many ports in the graph? What type of children nodes does it have (count the average number)? What type of parent nodes does it have (count the average number)?",
    "How many agg blocks are there in a common superblock? Also find the min number and max number of agg blocks.",
    "Does the graph have any information about power usage or physical location of the switches? Return 'Yes' or 'No'.",
    "What are the other ports on the switch that has the port ju1.a1.m1.s2c1.p10? Return a list.",
    "For each superblock, tell me the numbers of agg blocks, packet switches and ports. Return a list.",
    "Attach an attribute called capacity fraction to each of the port type node in the graph whose value is the fraction of their capacity relative to the total capacity of all ports in that switch. Return the updated graph.",
    "Divide the nodes into clusters using louvain communities algorithm. Add the cluster index as a node attrbute called 'Louvain Communities ClusterID'. Return the updated graph.",

]

answers=[
    # 3 easy ones
    "\ndef ground_truth_process_graph(graph_data):\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1.s2c1' and 'EK_PACKET_SWITCH' in graph_data.nodes[node]['type']:\n            target_node = node\n            break\n\n    if target_node is None:\n        return {'type': 'text', 'data': 'Packet switch not found'}\n\n    ports = []\n    for edge in graph_data.out_edges(target_node, data=True):\n        if edge[2]['type'] == 'RK_CONTAINS':\n            destination_node = edge[1]\n            if 'EK_PORT' in graph_data.nodes[destination_node]['type']:\n                ports.append(graph_data.nodes[destination_node]['name'])\n\n    return {'type': 'list', 'data': ports}",
    "\ndef ground_truth_process_graph(graph_data):\n    # Create a copy of the graph\n    graph_copy = graph_data.copy()\n\n    # Create a new node for the packet_switch 'ju1.a1.m1.s4c7'\n    packet_switch_node = 'ju1.a1.m1.s4c7'\n    graph_copy.add_node(packet_switch_node, type=['EK_PACKET_SWITCH'])\n\n    # Add ports to the packet_switch\n    for i in range(1, 6):\n        port_node = packet_switch_node + '.p' + str(i)\n        graph_copy.add_node(port_node, type=['EK_PORT'], physical_capacity_bps=1000)\n        graph_copy.add_edge(packet_switch_node, port_node, type='RK_CONTAINS')\n\n    # Add the packet_switch to the corresponding jupiter, aggregation block, and domain\n    jupiter_node = 'ju1'\n    agg_block_node = 'ju1.a1'\n    domain_node = 'ju1.a1.m1'\n\n    if not graph_copy.has_node(jupiter_node):\n        graph_copy.add_node(jupiter_node, type=['EK_JUPITER'])\n    if not graph_copy.has_node(agg_block_node):\n        graph_copy.add_node(agg_block_node, type=['EK_AGG_BLOCK'])\n    if not graph_copy.has_node(domain_node):\n        graph_copy.add_node(domain_node, type=['EK_DOMAIN'])\n\n    graph_copy.add_edge(jupiter_node, agg_block_node, type='RK_CONTAINS')\n    graph_copy.add_edge(agg_block_node, domain_node, type='RK_CONTAINS')\n    graph_copy.add_edge(domain_node, packet_switch_node, type='RK_CONTAINS')\n\n    return_object = {'type': 'graph', 'data': graph_copy}\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Find the node with the specified name\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1.s2c2.p14':\n            target_node = node\n            break\n\n    # Update the physical_capacity_bps attribute\n    if target_node is not None:\n        graph_data.nodes[target_node]['physical_capacity_bps'] = 4000 * 1000000\n\n    return_object = {\n        'type': 'graph',\n        'data': graph_data\n    }\n\n    return return_object",
    # 2nd turn
    "\ndef ground_truth_process_graph(graph_data):\n    control_point_packet_switch_nodes = []\n    \n    for node in graph_data.nodes(data=True):\n        if 'EK_CONTROL_POINT' in node[1]['type'] and 'EK_PACKET_SWITCH' in node[1]['type']:\n            for edge in graph_data.in_edges(node[0], data=True):\n                if edge[2]['type'] == 'RK_CONTAINS' and graph_data.nodes[edge[0]]['type'] == ['EK_AGG_BLOCK'] and graph_data.nodes[edge[0]]['name'] == 'ju1.a4.m4':\n                    control_point_packet_switch_nodes.append(node[0])\n                    break\n    \n    return_object = {\n        'type': 'list',\n        'data': control_point_packet_switch_nodes\n    }\n    \n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    control_domains = []\n    for node in graph_data.nodes(data=True):\n        if 'EK_CONTROL_DOMAIN' in node[1]['type']:\n            control_points = [edge[1] for edge in graph_data.out_edges(node[0], data=True) if edge[2]['type'] == 'RK_CONTAINS' and 'EK_CONTROL_POINT' in graph_data.nodes[edge[1]]['type']]\n            if len(control_points) >= 3:\n                control_domains.append(node[0])\n    return_object = {'type': 'list', 'data': control_domains}\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    for node, attrs in graph_data.nodes(data=True):\n        if 'EK_PACKET_SWITCH' in attrs['type']:\n            if attrs.get('packet_switch_attr', {}).get('switch_loc', {}).get('stage') == 3:\n                attrs['packet_switch_attr']['switch_loc']['stage'] = 5\n    return_object = {\n        'type': 'graph',\n        'data': graph_data\n    }\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    table_data = [['RACK', 'CHASSIS Count']]\n    for node in graph_data.nodes(data=True):\n        if 'EK_RACK' in node[1]['type']:\n            rack_node = node[0]\n            chassis_count = 0\n            for edge in graph_data.out_edges(rack_node, data=True):\n                if edge[2]['type'] == 'RK_CONTAINS':\n                    if 'EK_CHASSIS' in graph_data.nodes[edge[1]]['type']:\n                        chassis_count += 1\n            table_data.append([rack_node, chassis_count])\n    return_object = {'type': 'table', 'data': table_data}\n    return return_object",

    # 3 medium ones
    "\ndef ground_truth_process_graph(graph_data):\n    \n    # Find the packet switch node\n    packet_switch_node = None\n    for node in graph_data.nodes(data=True):\n        if 'EK_PACKET_SWITCH' in node[1]['type'] and node[0] == 'ju1.a2.m1.s2c2':\n            packet_switch_node = node[0]\n            break\n\n    if packet_switch_node is None:\n        return {'type': 'text', 'data': 'Packet switch not found'}\n\n    # Find all port nodes contained by the packet switch\n    port_nodes = []\n    for edge in graph_data.edges(data=True):\n        if edge[2]['type'] == 'RK_CONTAINS' and edge[0] == packet_switch_node:\n            port_nodes.append(edge[1])\n\n    # Sum the physical_capacity_bps attribute on the port nodes\n    total_bandwidth_bps = 0\n    for port_node in port_nodes:\n        total_bandwidth_bps += graph_data.nodes[port_node]['physical_capacity_bps']\n\n    # Convert to Mbps\n    total_bandwidth_mbps = total_bandwidth_bps / 1e6\n\n    return {'type': 'text', 'data': str(total_bandwidth_mbps)}",
    "\ndef ground_truth_process_graph(graph_data):\n    \n    agg_blocks = [node for node in graph_data.nodes if 'EK_AGG_BLOCK' in graph_data.nodes[node]['type']]\n    bandwidths = []\n\n    for agg_block in agg_blocks:\n        packet_switches = [node for node in graph_data.successors(agg_block) if 'EK_PACKET_SWITCH' in graph_data.nodes[node]['type']]\n        total_bandwidth = 0\n\n        for packet_switch in packet_switches:\n            ports = [node for node in graph_data.successors(packet_switch) if 'EK_PORT' in graph_data.nodes[node]['type']]\n\n            for port in ports:\n                total_bandwidth += graph_data.nodes[port]['physical_capacity_bps'] / 1e6  # Convert to Mbps\n\n        bandwidths.append([agg_block, total_bandwidth])\n\n    return_object = {\n        'type': 'table',\n        'data': [['AGG_BLOCK', 'Bandwidth']] + bandwidths\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    \n    # Helper function to convert bps to Mbps\n    def bps_to_mbps(bps):\n        return bps / (10**6)\n\n    # Find the 'ju1.a1.m1' node\n    target_node = None\n    for node in graph_data.nodes:\n        if graph_data.nodes[node].get('name') == 'ju1.a1.m1':\n            target_node = node\n            break\n\n    # Find all Chassis nodes\n    chassis_nodes = [n for n in graph_data.nodes if 'EK_CHASSIS' in graph_data.nodes[n]['type']]\n\n    # Calculate the total bandwidth for each Chassis\n    chassis_bandwidth = {}\n    for chassis in chassis_nodes:\n        bandwidth = 0\n        packet_switch_nodes = [n for n in graph_data.neighbors(chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n        for packet_switch in packet_switch_nodes:\n            port_nodes = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n            for port in port_nodes:\n                bandwidth += graph_data.nodes[port]['physical_capacity_bps']\n        chassis_bandwidth[chassis] = bps_to_mbps(bandwidth)\n\n    # Sort Chassis by bandwidth\n    sorted_chassis = sorted(chassis_bandwidth.items(), key=lambda x: x[1], reverse=True)\n\n    # Get the first and second largest Chassis\n    top_chassis = sorted_chassis[:2]\n\n    # Create the table\n    table = [['Chassis', 'Bandwidth']]\n    for chassis, bandwidth in top_chassis:\n        table.append([chassis, bandwidth])\n\n    return_object = {\n        'type': 'table',\n        'data': table\n    }\n\n    return return_object",
    # 2nd turn
    "\ndef ground_truth_process_graph(graph_data):\n    total_capacity = 0\n    port_count = 0\n\n    for node in graph_data.nodes(data=True):\n        if 'EK_PACKET_SWITCH' in node[1]['type']:\n            for neighbor in graph_data.neighbors(node[0]):\n                neighbor_data = graph_data.nodes[neighbor]\n                if 'EK_PORT' in neighbor_data['type']:\n                    total_capacity += neighbor_data['physical_capacity_bps']\n                    port_count += 1\n\n    average_capacity = total_capacity / port_count if port_count > 0 else 0\n\n    return_object = {\n        'type': 'text',\n        'data': str(average_capacity)\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    agg_blocks = [n for n, d in graph_data.nodes(data=True) if 'EK_AGG_BLOCK' in d['type']]\n    result = []\n    for agg_block in agg_blocks:\n        switch_count = 0\n        port_count = 0\n        for node in nx.descendants(graph_data, agg_block):\n            if 'EK_PACKET_SWITCH' in graph_data.nodes[node]['type']:\n                switch_count += 1\n            elif 'EK_PORT' in graph_data.nodes[node]['type']:\n                port_count += 1\n        result.append([agg_block, switch_count, port_count])\n    \n    return_object = {\n        'type': 'table',\n        'data': [['AGG_BLOCK', 'Switch Count', 'Port Count']] + result\n    }\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    packet_switches = []\n    for node in graph_data.nodes(data=True):\n        if 'EK_AGG_BLOCK' in node[1]['type'] and node[1]['name'] == 'ju1.a1.m1':\n            for edge in graph_data.out_edges(node[0], data=True):\n                if edge[2]['type'] == 'RK_CONTAINS':\n                    dest_node = graph_data.nodes[edge[1]]\n                    if 'EK_PACKET_SWITCH' in dest_node['type']:\n                        packet_switches.append(edge[1])\n\n    avg_capacity = []\n    for ps in packet_switches:\n        capacities = []\n        for edge in graph_data.out_edges(ps, data=True):\n            if edge[2]['type'] == 'RK_CONTAINS':\n                dest_node = graph_data.nodes[edge[1]]\n                if 'EK_PORT' in dest_node['type']:\n                    capacities.append(dest_node['physical_capacity_bps'])\n        avg_capacity.append((ps, sum(capacities) / len(capacities)))\n\n    avg_capacity.sort(key=lambda x: x[1], reverse=True)\n    table_data = [['Packet Switch', 'Average Capacity (bps)']]\n    for item in avg_capacity:\n        table_data.append([item[0], item[1]])\n\n    return_object = {\n        'type': 'table',\n        'data': table_data\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Initialize the list to store packet switch nodes and their capacities\n    packet_switch_nodes = []\n    total_capacity = 0\n\n    # Iterate over all nodes in the graph\n    for node in graph_data.nodes(data=True):\n        # Check if the node is a packet switch\n        if 'EK_PACKET_SWITCH' in node[1]['type']:\n            # Calculate the total capacity of the packet switch\n            capacity = sum([graph_data.nodes[neighbor]['physical_capacity_bps'] for neighbor in graph_data.neighbors(node[0]) if 'EK_PORT' in graph_data.nodes[neighbor]['type']])\n            # Append the node and its capacity to the list\n            packet_switch_nodes.append((node[0], capacity))\n            total_capacity += capacity\n\n    # Calculate the average capacity\n    avg_capacity = total_capacity / len(packet_switch_nodes)\n\n    # Find all packet switch nodes that have capacity more than the average\n    result = [node for node, capacity in packet_switch_nodes if capacity > avg_capacity]\n\n    # Return the result\n    return_object = {'type': 'list', 'data': result}\n    return return_object",

    # 3 hard ones
    "\ndef ground_truth_process_graph(graph_data):\n    # Filter nodes and edges\n    filtered_nodes = [n for n, d in graph_data.nodes(data=True) if 'EK_SUPERBLOCK' in d['type'] or 'EK_AGG_BLOCK' in d['type']]\n    filtered_edges = [(u, v, d) for u, v, d in graph_data.edges(data=True) if d['type'] == 'RK_CONTAINS' and u in filtered_nodes or v in filtered_nodes]\n\n    # Create a new graph with the filtered nodes and edges\n    new_graph = nx.DiGraph()\n    new_graph.add_nodes_from(filtered_nodes)\n    new_graph.add_edges_from(filtered_edges)\n\n    # Return the graph object\n    return_object = {\n        'type': 'graph',\n        'data': new_graph\n    }\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Remove packet switch 'ju1.a1.m1.s2c4' from Chassis c4\n    packet_switch_to_remove = 'ju1.a1.m1.s2c4'\n    chassis_to_balance = 'c4'\n    if packet_switch_to_remove in graph_data.nodes():\n        graph_data.remove_node(packet_switch_to_remove)\n\n    # Find all Chassis nodes\n    chassis_nodes = [n for n, attr in graph_data.nodes(data=True) if 'EK_CHASSIS' in attr['type']]\n\n    # Calculate the total capacity for each Chassis\n    chassis_capacity = {}\n    for chassis in chassis_nodes:\n        packet_switches = [n for n in graph_data.neighbors(chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n        total_capacity = 0\n        for packet_switch in packet_switches:\n            ports = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n            for port in ports:\n                total_capacity += graph_data.nodes[port]['physical_capacity_bps']\n        chassis_capacity[chassis] = total_capacity\n\n    # Calculate the average capacity\n    average_capacity = sum(chassis_capacity.values()) / len(chassis_capacity)\n\n    # Balance the capacity between Chassis\n    for chassis in chassis_nodes:\n        if chassis_capacity[chassis] < average_capacity:\n            extra_capacity = average_capacity - chassis_capacity[chassis]\n            # Find a packet switch from another chassis with enough capacity\n            for other_chassis in chassis_nodes:\n                if other_chassis != chassis:\n                    other_packet_switches = [n for n in graph_data.neighbors(other_chassis) if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n                    for packet_switch in other_packet_switches:\n                        ports = [n for n in graph_data.neighbors(packet_switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n                        packet_switch_capacity = sum(graph_data.nodes[port]['physical_capacity_bps'] for port in ports)\n                        if packet_switch_capacity >= extra_capacity:\n                            # Move the packet switch to the current chassis\n                            graph_data.remove_edge(other_chassis, packet_switch)\n                            graph_data.add_edge(chassis, packet_switch, type='RK_CONTAINS')\n                            break\n\n    return {'type': 'graph', 'data': graph_data}",
    "\ndef ground_truth_process_graph(graph_data):\n    packet_switches = ['ju1.a1.m1.s2c1', 'ju1.a1.m1.s2c2', 'ju1.a1.m1.s2c3', 'ju1.a1.m1.s2c4', 'ju1.a1.m1.s2c5']\n    removed_ports = []\n\n    for switch in packet_switches:\n        ports = [n for n in graph_data.neighbors(switch) if 'EK_PORT' in graph_data.nodes[n]['type']]\n        ports_capacity = {port: graph_data.nodes[port]['physical_capacity_bps'] for port in ports}\n        sorted_ports = sorted(ports_capacity.items(), key=lambda x: x[1], reverse=True)\n\n        for i in range(5):\n            removed_port = sorted_ports.pop(0)\n            removed_ports.append(removed_port[0])\n            graph_data.remove_node(removed_port[0])\n\n    return_object = {\n        'type': 'list',\n        'data': removed_ports\n    }\n\n    return return_object",
    # 2nd turn
    "\ndef ground_truth_process_graph(graph_data):\n    source_node = None\n    target_node = None\n\n    for node in graph_data.nodes(data=True):\n        if 'EK_CONTROL_DOMAIN' in node[1]['type'] and node[1]['name'] == 'ju1.a1.dom':\n            source_node = node[0]\n        if 'EK_PORT' in node[1]['type'] and node[1]['name'] == 'ju1.a1.m1.s2c1.p1':\n            target_node = node[0]\n\n    if source_node is None or target_node is None:\n        return {'type': 'text', 'data': 'Source or target node not found'}\n\n    all_paths = list(nx.all_simple_paths(graph_data, source_node, target_node))\n    ranked_paths = sorted(all_paths, key=len)\n\n    return {'type': 'list', 'data': ranked_paths}",
    "\ndef ground_truth_process_graph(graph_data):\n    def find_chassis_nodes(graph):\n        return [node for node, attrs in graph.nodes(data=True) if 'EK_CHASSIS' in attrs['type']]\n\n    def find_superblock_nodes(graph):\n        return [node for node, attrs in graph.nodes(data=True) if 'EK_SUPERBLOCK' in attrs['type']]\n\n    def find_chassis_in_superblock(graph, superblock):\n        return [node for node in graph.neighbors(superblock) if 'EK_CHASSIS' in graph.nodes[node]['type']]\n\n    def calculate_redundancy(graph, chassis_pairs):\n        redundancy = {}\n        for pair in chassis_pairs:\n            paths = nx.all_simple_paths(graph, source=pair[0], target=pair[1])\n            redundancy[pair] = len(list(paths)) - 1\n        return redundancy\n\n    chassis_nodes = find_chassis_nodes(graph_data)\n    superblock_nodes = find_superblock_nodes(graph_data)\n\n    redundancy_data = []\n    for superblock in superblock_nodes:\n        chassis_in_superblock = find_chassis_in_superblock(graph_data, superblock)\n        chassis_pairs = [(chassis1, chassis2) for idx1, chassis1 in enumerate(chassis_in_superblock) for chassis2 in chassis_in_superblock[idx1 + 1:]]\n        redundancy = calculate_redundancy(graph_data, chassis_pairs)\n        redundancy_data.append([superblock, redundancy])\n\n    return_object = {\n        'type': 'table',\n        'data': redundancy_data\n    }\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    \n    # Get all CONTROL_DOMAIN nodes\n    control_nodes = [node for node, attr in graph_data.nodes(data=True) if 'EK_CONTROL_DOMAIN' in attr['type']]\n\n    # Get all PACKET_SWITCH nodes\n    packet_switch_nodes = [node for node, attr in graph_data.nodes(data=True) if 'EK_PACKET_SWITCH' in attr['type']]\n\n    removable_nodes = []\n\n    for packet_node in packet_switch_nodes:\n        # Create a copy of the graph\n        graph_copy = graph_data.copy()\n\n        # Remove the packet node\n        graph_copy.remove_node(packet_node)\n\n        # Check if all control nodes are still connected\n        if nx.is_strongly_connected(graph_copy.subgraph(control_nodes)):\n            removable_nodes.append(packet_node)\n\n    return_object = {'type': 'list', 'data': removable_nodes}\n\n    return return_object",
    "\ndef ground_truth_process_graph(graph_data):\n    # Initialize the new PACKET_SWITCH node and its PORT nodes\n    new_switch = 'ju1.a1.m1.s2c9'\n    new_ports = ['ju1.a1.m1.s2c9.p{}'.format(i) for i in range(1, 6)]\n    port_capacity = 1000000000\n\n    # Add the new PACKET_SWITCH node to the graph\n    graph_data.add_node(new_switch, type=['EK_PACKET_SWITCH'])\n\n    # Add the new PORT nodes to the graph and connect them to the new PACKET_SWITCH node\n    for port in new_ports:\n        graph_data.add_node(port, type=['EK_PORT'], physical_capacity_bps=port_capacity)\n        graph_data.add_edge(new_switch, port, type='RK_CONTAINS')\n\n    # Calculate the average capacity of each AGG_BLOCK node\n    agg_blocks = [node for node, attr in graph_data.nodes(data=True) if 'EK_AGG_BLOCK' in attr['type']]\n    agg_block_capacities = {}\n    for block in agg_blocks:\n        port_nodes = [node for node in graph_data.neighbors(block) if 'EK_PORT' in graph_data.nodes[node]['type']]\n        total_capacity = sum(graph_data.nodes[port]['physical_capacity_bps'] for port in port_nodes)\n        agg_block_capacities[block] = total_capacity / len(port_nodes) if port_nodes else 0\n\n    # Find the AGG_BLOCK node with the lowest average capacity\n    min_block = min(agg_block_capacities, key=agg_block_capacities.get)\n\n    # Connect the new PACKET_SWITCH node to the AGG_BLOCK node with the lowest average capacity\n    graph_data.add_edge(min_block, new_switch, type='RK_CONTAINS')\n\n    return_object = {\n        'type': 'graph',\n        'data': graph_data\n    }\n\n    return return_object",

    # From Srikanth
    "\ndef ground_truth_process_graph(graph_data):\n    switch_name = 'ju1.a1.m1.s2c1'\n    ports = [n for n in graph_data.neighbors(switch_name) if 'EK_PORT' in graph_data.nodes[n]['type']]\n    total_capacity = sum([graph_data.nodes[port]['physical_capacity_bps'] for port in ports])\n\n    return {'type': 'text', 'data': str(total_capacity)}",
    '\ndef ground_truth_process_graph(graph_data):\n\tswitch_name = \'ju1.a2.m3.s2c3\'\n\tall_switches = [x for x, y in graph_data.nodes(data=True) if \'EK_PACKET_SWITCH\' in y[\'type\']]\n\tswitch_cap = sum([graph_data.nodes[port][\'physical_capacity_bps\'] for port in graph_data.neighbors(switch_name) if \'EK_PORT\' in graph_data.nodes[port][\'type\']])\n\n\tnum_ahead = 0\n\texample_switch_ahead = ""\n\tfor s in all_switches:\n\t\tif s ==\tswitch_name: next\n\t\tthis_switch_cap = sum([graph_data.nodes[port][\'physical_capacity_bps\'] for port in graph_data.neighbors(s) if \'EK_PORT\' in graph_data.nodes[port][\'type\']])\n\t\tif this_switch_cap > switch_cap:\n\t\t\tnum_ahead = num_ahead + 1\n\t\t\texample_switch_ahead = s\n\treturn {\'type\': \'text\', \'data\': {\'number of such switches\': num_ahead, \'example such switch\': example_switch_ahead}}\n',
    "\ndef ground_truth_process_graph(graph_data):\n    all_chassis = [x for x, y in graph_data.nodes(data=True) if 'EK_CHASSIS' in y['type']]\n    num_switches_in_chassis = [len([s for s in graph_data.neighbors(c) if 'EK_PACKET_SWITCH' in graph_data.nodes[s]['type']]) for c in all_chassis]\n    avg_num_switches = np.average(num_switches_in_chassis)\n\n    chassis_with_more = list()\n    chassis_with_less = list()\n    if np.min(num_switches_in_chassis) < avg_num_switches:\n        x = np.argwhere(num_switches_in_chassis < avg_num_switches)[0]\n        chassis_with_less = [all_chassis[x], num_switches_in_chassis[x]]\n    if np.max(num_switches_in_chassis) > avg_num_switches:\n        x = np.argwhere(num_switches_in_chassis > avg_num_switches)[0]\n        chassis_with_more = [all_chassis[x], num_switches_in_chassis[x]]\n\n    return {'type': 'text', 'data': {'Typical chassis, Packet switch count:': avg_num_switches,\n                                     'Example chassis with fewer switches:': print(*chassis_with_less),\n                                     'Example chassis with more switches:': print(*chassis_with_more)\n                                     }}\n",
    '\ndef ground_truth_process_graph(graph_data):\n    all_points = [x for x, y in graph_data.nodes(data=True) if \'EK_PORT\' in y[\'type\']]\n    num_cp_neighbors = {\'pred\': [], \'succ\': []}\n    num_cp_neighbors_by_type = {\'pred\': {}, \'succ\': {}}\n    for cp in all_points:\n        preds = [x for x in graph_data.predecessors(cp) if x != cp]\n        succs = [x for x in graph_data.successors(cp) if x != cp]\n        for n in preds:\n            alltypes = list(graph_data.nodes[n][\'type\'])\n            for t in alltypes:\n                v = 0\n                if t in num_cp_neighbors_by_type["pred"]:\n                    v = num_cp_neighbors_by_type["pred"][t]\n                num_cp_neighbors_by_type["pred"][t] = v + (1.0 / len(alltypes))\n        for n in succs:\n            alltypes = list(graph_data.nodes[n][\'type\'])\n            for t in alltypes:\n                v = 0\n                if t in num_cp_neighbors_by_type["succ"]:\n                    v = num_cp_neighbors_by_type["succ"][t]\n                num_cp_neighbors_by_type["succ"][t] = v + (1.0 / len(alltypes))\n\n        num_cp_neighbors["pred"].append(len(preds))\n        num_cp_neighbors["succ"].append(len(succs))\n\n    for type in ["pred", "succ"]:\n        total_nbr_count = np.sum(num_cp_neighbors[type])\n        for k, v in num_cp_neighbors_by_type[type].items():\n            num_cp_neighbors_by_type[type][k] = v * 1.0 / total_nbr_count\n\n    return {\'type\': \'text\',\n            \'data\': "There are {} ports in the graph. A typical port has {} predecessors with types: {} and {} successors with types: {}".format(\n                len(all_points),\n                np.average(num_cp_neighbors["pred"]),\n                num_cp_neighbors_by_type["pred"],\n                np.average(num_cp_neighbors["succ"]),\n                num_cp_neighbors_by_type["succ"])}\n',
    "\ndef ground_truth_process_graph(graph_data):\n    all_superblocks = [x for x, y in graph_data.nodes(data=True) if 'EK_SUPERBLOCK' in y['type']]\n\n    result = list()\n    for sb in all_superblocks:\n        num_agg_blocks = \\\n            len([x for x in graph_data.predecessors(sb) if 'EK_AGG_BLOCK' in graph_data.nodes[x]['type']]) + \\\n            len([x for x in graph_data.successors(sb) if 'EK_AGG_BLOCK' in graph_data.nodes[x]['type']])\n\n        result.append(num_agg_blocks)\n\n    return {'type': 'text',\n            'data': 'There are {} agg blocks on average in a superblock. The max and min values are {} and {} respectively.'.format(\n                np.average(num_agg_blocks), np.min(num_agg_blocks), np.max(num_agg_blocks))}\n",
    '\ndef ground_truth_process_graph(graph_data):\n    found = False\n    for n in graph_data.nodes(data=True):\n        s = str(n).lower()\n        if "switch" in s and ("power" in s or "physical" in s or "location" in s):\n            found = True\n\n    return {\'type\': \'text\', \'data\': "Yes" if found else "No"}\n',
    "\ndef ground_truth_process_graph(graph_data):\n    port = 'ju1.a1.m1.s2c1.p10'\n    switch_containing_this_port = [s for s in graph_data.predecessors(port) if 'EK_PACKET_SWITCH' in graph_data.nodes[s]['type']][0]\n    other_ports = [p for p in graph_data.successors(switch_containing_this_port) if 'EK_PORT' in graph_data.nodes[p]['type'] and p != port]\n    return {'type': 'list', 'data': other_ports}\n",
    "\ndef ground_truth_process_graph(graph_data):\n    all_superblocks = [n for n in graph_data.nodes() if 'EK_SUPERBLOCK' in graph_data.nodes[n]['type']]\n    result_list = list()\n    for sb in all_superblocks:\n        agg_blocks = [n for n in graph_data.successors(sb) if 'EK_AGG_BLOCK' in graph_data.nodes[n]['type']]\n\n        agg_block_count = len(agg_blocks)\n        packet_switch_count = 0\n        port_count = 0\n        for ab in agg_blocks:\n            packet_switches = [n for n in graph_data.successors(ab) if\n                               'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n            packet_switch_count = packet_switch_count + len(packet_switches)\n            for ps in packet_switches:\n                ports = [n for n in graph_data.successors(ps) if 'EK_PORT' in graph_data.nodes[n]['type']]\n                port_count = port_count + len(ports)\n\n        result_list.append([sb, agg_block_count, packet_switch_count, port_count])\n    return {'type': 'list', 'data': result_list}\n",
    "\ndef ground_truth_process_graph(graph_data):\n    attribute_dict = dict()\n    packet_switches = [n for n in graph_data.nodes() if 'EK_PACKET_SWITCH' in graph_data.nodes[n]['type']]\n    for p in packet_switches:\n        ports = [port for port in graph_data.successors(p) if 'EK_PORT' in graph_data.nodes[port]['type']]\n        caps = [graph_data.nodes[port]['physical_capacity_bps'] for port in ports]\n        total_caps = sum(caps)\n        caps = [x * 1.0 / total_caps for x in caps]\n        for index in range(len(ports)):\n            attribute_dict[ports[index]] = caps[index]\n\n    nx.set_node_attributes(graph_data, attribute_dict, 'capacity fraction')\n    return {'type': 'graph', 'data': graph_data}\n",
    "\ndef ground_truth_process_graph(graph_data):\n    clusters = nx.community.louvain_communities(graph_data)\n    cluster_dict = dict()\n    for clusterindex in range(len(clusters)):\n        for n in clusters[clusterindex]:\n            cluster_dict[n] = clusterindex\n    nx.set_node_attributes(g2['data'], cluster_dict, 'Louvain Communities ClusterID')\n    return {'type': 'graph', 'data': graph_data}\n",

]

# File to save the jsonl
output_file = 'benchmark_data/app_malt_dataset.jsonl'

# Prepare data in the required format
data = []
for prompt, answer in zip(prompts, answers):
    entry = {
        "messages": [
            {"question": prompt},
            {"answer": answer},
            {"task": "capacity planning"}
        ]
    }
    data.append(entry)

# Write data to jsonl file
with open(output_file, 'w') as f:
    for entry in data:
        f.write(json.dumps(entry) + '\n')

print(f"Data successfully written to {output_file}")
